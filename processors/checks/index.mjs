/*
 * A Morio stream processor to handle health check data
 *
 * This is designed to handle data in the 'checks' topic, which
 * typically holds data generated by the watcher service (Heartbeat),
 * although it can also process other data if it's well-formatted.
 *
 * This method will be called for ever incoming message on the checks topic
 *
 * @param {object} data - The data from RedPanda
 * @param {obectt} tools - The tools object
 * @param {string} topic - The topic the data came from
 */
export default function checksStreamProcessor (data, tools, topic) {
  /*
   * Only process data that is in the correct format
   */
  if (!data?.monitor?.id || !data?.monitor?.name) {
    return tools.note('Invalid healthcheck data', data)
  }

  if (!data.url?.full) {
    return tools.cache.note(`Healtcheck has no full URL`, data)
  }

  /*
   * Summarize the healthcheck for the cache
   */
  const summary = healthcheckSummary(data, tools)

  /*
   * Update the cache
   */
  if (tools.getSettings('tap.checks.cache', false)) tools.cache.healthcheck(summary, data, tools.getSettings('tap.checks', {}))

  /*
   * Escalate if needed
   */
  if (
    !summary.up &&
    tools.getSettings('tap.checks.eventify', false) &&
    data.url.full.indexOf('MORIO_IGNORE_WHEN_DOWN') === -1
  ) tools.produce.event({
    context: tools.create.context('check', summary.id, summary.from),
    href: `https://${tools.node.cluster}/boards/checks/${summary.id}`,
    time: summary.time,
    title: `Health check failed: ${summary.name}`,
    type: `${summary.type}.healthcheck.down`,
    data: {
      from: summary.from,
      id: summary.id,
      type: summary.type,
    },
  })

  /*
   * Can't do a simple if (!dbce) here because dbce can be zero
   */
  if (summary.dbce !== undefined) {
    const { certificate_days = 21 } = tools.getSettings('tap.checks', {})
    if (
      summary.dbce < certificate_days &&
      /*
       * This is a way to supress escalation of super short-lived certificates
       * like Morio's own internal CA which rotates its cert ever couple of hours
       */
      data.url.full.indexOf('MORIO_IGNORE_CERTIFICATE_EXPIRY') === -1
    ) {
      tools.produce.event({
        context: tools.create.context(`tls.certificate.${tools.format.escape(data.url.full)}`),
        href: `https://${tools.node.cluster}/boards/checks/${summary.id}`,
        title: `⏳ Certificate will expire in ${summary.dbce} days: ${data?.url?.full}`,
        time: summary.time,
        type: 'tls.certificate.expiry',
        data: { days_before_expiry: summary.dbce }
      })
    }
  }
}

/*
 * Takes healthcheck data and returns and array with the key observations
 *
 * @param {object} data - The healthcheck data
 * @return {array} summary - An array holding:
 *   - up (1 or 0)
 *   - the ms it took to complete the healthcheck
 *   - days until the certificate expires
 */
function healthcheckSummary (data, tools) {
  return {
    // Up or not?
    up: (tools.getSettings('tap.checks.up_values', []).indexOf(data.monitor.status.toLowerCase()) !== -1) ? 1 : 0,
    // Milliseconds the healthcheck took
    ms: Math.ceil(data.monitor.duration.us/1000),
    // Days before certificate expiry
    dbce: (
      tools.getSettings('tap.checks.certificate_check', false) &&
      data.monitor.type === 'http' &&
      data.tls &&
      data.url?.scheme === 'https'
    ) ? checkCertificateExpiry(data, tools) : undefined,
    // Uptime from historic healthchecks
    uptime: data.state.up / data.state.checks,
    // Start of the historic healthchecks
    uptime_since: data.state.started_at,
    // Time of this specific healthcheck
    time: tools.time.when(data),
    // Type of healthcheck
    type: data.monitor.type,
    // ID of the healthcheck
    id: data.monitor.id,
    // Name of the healthcheck
    name: data.monitor.name,
    // URL of the healthcheck
    url: data.url.full,
    /*
     * Name/ID of the agent
     * This helps us differentiate when running the same healthcheck from 2 places
     * Something tha tis very useful when your infra spans multiple sites
     */
    from: data.agent.name || agent.id,
  }
}

/*
 * Checks certificate validity
 *
 * @param {object} data - The healthcheck data
 * @param {object} tools - The tools object
 * @return {number} days - The number of days until expiry
 */
const checkCertificateExpiry = (data, tools) => {
  const ms = Math.floor(
    (new Date(data.tls.certificate_not_valid_after).getTime())
    - tools.time.now()
  )

  return Math.floor(ms / (24 * 3600000))
}

/*
 * This is used for both the UI and to generate the default settings
 */
export const info = {
  title: 'Health checks stream processor',
  about: `This stream processor will process health check data flowing through your Morio collection.

It can cache recent health check data, as well as enventify them for event-driven automation.
It also supports verifying the expiry of TLS certificates.
`,
  settings: {
    enabled: {
      title: 'Enable health checks stream processor',
      dflt: true,
      type: 'list',
      list: [
        {
          val: false,
          label: 'Disabled',
          about: 'Select this to completely disabled this stream processor',
        },
        {
          val: true,
          label: 'Enabled',
          about: 'Select this to enable this stream processor',
        },
      ]
    },
    topics: {
      dflt: ['checks'],
      title: 'List of topics to subscribe to',
      about: `Changing this from the default \`checks\` is risky`,
      type: 'labels',
    },
    cache: {
      dflt: true,
      title: 'Cache health check data',
      type: 'list',
      list: [
        {
          val: false,
          label: 'Do not cache health check data (disable)',
        },
        {
          val: true,
          label: 'Cache recent health check',
          about: 'Caching health check data allows consulting it through the dashboards provided by Morio&apos;s UI service'
        },
      ],
    },
    ttl: {
      dflt: 2,
      title: 'Maxumum age of cached health checks',
      about: 'Health check data in the cache will expire after this amount of time',
      labelBL: 'In hours',
      type: 'number'
    },
    eventify: {
      dflt: true,
      title: 'Eventify health check data',
      type: 'list',
      list: [
        {
          val: false,
          label: 'Do not eventify health check data (disable)',
        },
        {
          val: true,
          label: 'Auto-create events based on health check data',
          about: 'Eventifying health check data allows for event-driven automation and monitoring based on health check information',
        },
      ],
    },
    up_values: {
      dflt: [1, "green", "up"],
      title: "Up values",
      about: "All of the different health check return values that should be considered 'up'",
      type: 'labels',
    },
    certificate_check: {
      dflt: true,
      title: 'Verify certificate expiry',
      type: 'list',
      list: [
        {
          val: false,
          label: 'Do not verify certificate expiry',
        },
        {
          val: true,
          label: 'Verify certificate expiry',
          about: 'Check certificate expiry, and create an event when expiry approaches',
        },
      ],
    },
    certificate_days: {
      dflt: 21,
      title: 'Days before certificate expiry to escalate',
      about: 'How many days before certifcates expire would you like to raise an event?',
      labelBL: 'In days',
      type: 'number'
    }
  }
}

